<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ForestDraw — GIS Sketch Tool</title>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css"/>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>

<style>
  @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Syne:wght@400;600;800&display=swap');

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --forest: #1a3a2a;
    --moss: #2d5a3d;
    --leaf: #4a8c5c;
    --lime: #8bc34a;
    --bark: #3d2b1f;
    --cream: #f5f0e8;
    --sand: #e8dfc8;
    --ink: #111;
  }

  body {
    font-family: 'Space Mono', monospace;
    background: var(--forest);
    color: var(--cream);
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 20px;
    height: 54px;
    background: var(--bark);
    border-bottom: 2px solid var(--lime);
    flex-shrink: 0;
    z-index: 1000;
  }

  .logo {
    font-family: 'Syne', sans-serif;
    font-weight: 800;
    font-size: 1.2rem;
    letter-spacing: -0.5px;
    color: var(--lime);
    text-decoration: none;
  }

  .logo span { color: var(--cream); font-size: 0.85rem; font-family: 'Space Mono', monospace; font-weight: 400; margin-left: 10px; opacity: 0.7; }

  .toolbar {
    display: flex;
    gap: 6px;
    align-items: center;
  }

  .tool-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 14px;
    background: var(--moss);
    border: 1px solid var(--leaf);
    color: var(--cream);
    font-family: 'Space Mono', monospace;
    font-size: 0.72rem;
    cursor: pointer;
    transition: all 0.15s;
    letter-spacing: 0.5px;
    text-transform: uppercase;
  }

  .tool-btn:hover, .tool-btn.active {
    background: var(--leaf);
    border-color: var(--lime);
    color: #fff;
  }

  .tool-btn svg { width: 14px; height: 14px; flex-shrink: 0; }

  .sep { width: 1px; height: 28px; background: var(--leaf); margin: 0 4px; }

  .export-btn {
    background: var(--lime);
    border-color: var(--lime);
    color: var(--forest);
    font-weight: 700;
  }

  .export-btn:hover {
    background: #a5d65f;
    border-color: #a5d65f;
    color: var(--forest);
  }

  .clear-btn {
    background: transparent;
    border-color: #c0392b;
    color: #e74c3c;
  }
  .clear-btn:hover {
    background: #c0392b;
    color: #fff;
    border-color: #c0392b;
  }

  #map {
    flex: 1;
    width: 100%;
  }

  .status-bar {
    height: 28px;
    background: var(--bark);
    border-top: 1px solid var(--moss);
    display: flex;
    align-items: center;
    padding: 0 16px;
    gap: 20px;
    font-size: 0.65rem;
    color: var(--sand);
    flex-shrink: 0;
  }

  .status-bar span { color: var(--lime); }

  /* Override leaflet draw toolbar — hide it, we use our own */
  .leaflet-draw-toolbar { display: none !important; }
  .leaflet-draw-actions { display: none !important; }

  /* Custom draw actions that DO appear */
  .leaflet-draw-actions.leaflet-draw-actions-top { display: flex !important; }

  /* Cruise grid panel */
  .cruise-panel {
    position: absolute;
    right: 60px;
    top: 70px;
    width: 240px;
    background: var(--bark);
    border: 1px solid var(--leaf);
    border-top: 3px solid var(--lime);
    z-index: 1000;
    padding: 14px;
    display: none;
    flex-direction: column;
    gap: 10px;
  }
  .cruise-panel.open { display: flex; }
  .cruise-panel h3 {
    font-family: 'Syne', sans-serif;
    font-size: 0.8rem;
    font-weight: 800;
    color: var(--lime);
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 2px;
  }
  .field-label {
    font-size: 0.62rem;
    color: var(--sand);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 3px;
  }
  .cruise-input {
    width: 100%;
    background: var(--forest);
    border: 1px solid var(--leaf);
    color: var(--cream);
    font-family: 'Space Mono', monospace;
    font-size: 0.75rem;
    padding: 6px 8px;
  }
  .cruise-input:focus { outline: 1px solid var(--lime); }
  .cruise-row { display: flex; gap: 8px; }
  .field-group { display: flex; flex-direction: column; flex: 1; }
  .cruise-actions { display: flex; gap: 6px; margin-top: 4px; }
  .cruise-actions button {
    flex: 1;
    padding: 7px 4px;
    font-family: 'Space Mono', monospace;
    font-size: 0.65rem;
    font-weight: 700;
    text-transform: uppercase;
    cursor: pointer;
    border: 1px solid var(--leaf);
    letter-spacing: 0.5px;
  }
  .btn-generate { background: var(--lime); color: var(--forest); border-color: var(--lime); }
  .btn-generate:hover { background: #a5d65f; }
  .btn-clear-grid { background: transparent; color: #e74c3c; border-color: #c0392b; }
  .btn-clear-grid:hover { background: #c0392b; color: #fff; }
  .cruise-info {
    font-size: 0.62rem;
    color: var(--sand);
    border-top: 1px solid var(--moss);
    padding-top: 8px;
    margin-top: 2px;
  }
  .cruise-info span { color: var(--lime); }

  .notification {
    position: fixed;
    bottom: 40px;
    left: 50%;
    transform: translateX(-50%) translateY(20px);
    background: var(--lime);
    color: var(--forest);
    font-family: 'Space Mono', monospace;
    font-size: 0.75rem;
    font-weight: 700;
    padding: 10px 20px;
    opacity: 0;
    transition: all 0.3s;
    pointer-events: none;
    z-index: 9999;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  .notification.show {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }

  .upload-btn {
    background: transparent;
    border-color: var(--leaf);
    color: var(--sand);
  }
  .upload-btn:hover {
    background: var(--leaf);
    border-color: var(--lime);
    color: #fff;
  }

  .drop-overlay {
    position: absolute;
    top: 54px;
    left: 0;
    right: 0;
    bottom: 28px;
    background: rgba(15, 35, 24, 0.88);
    border: 4px dashed var(--lime);
    z-index: 2000;
    display: none;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 14px;
    pointer-events: none;
  }
  .drop-overlay.active { display: flex; }
  .drop-overlay svg { width: 52px; height: 52px; stroke: var(--lime); opacity: 0.9; }
  .drop-overlay p {
    font-family: 'Syne', sans-serif;
    font-weight: 800;
    font-size: 1.5rem;
    color: var(--lime);
    letter-spacing: -0.5px;
  }
  .drop-overlay small {
    font-size: 0.7rem;
    color: var(--sand);
    opacity: 0.7;
    letter-spacing: 0.5px;
  }

  .poly-checklist {
    max-height: 88px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 3px;
    border: 1px solid var(--leaf);
    padding: 5px 7px;
    background: var(--forest);
  }
  .poly-check {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.68rem;
    color: var(--cream);
    cursor: pointer;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex-shrink: 0;
  }
  .poly-check input[type=checkbox] { accent-color: var(--lime); flex-shrink: 0; cursor: pointer; }
  .poly-check.empty { opacity: 0.5; cursor: default; font-style: italic; }

  /* ── Location button & dot ───────────────────────────────────────────── */
  .locate-btn { background: transparent; border-color: #1976d2; color: #64b5f6; }
  .locate-btn:hover  { background: #1565c0; border-color: #2196f3; color: #fff; }
  .locate-btn.active { background: #1565c0; border-color: #2196f3; color: #fff; }

  .loc-dot {
    width: 14px; height: 14px;
    background: #2196f3;
    border: 2.5px solid #fff;
    border-radius: 50%;
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    z-index: 2;
    box-shadow: 0 1px 5px rgba(0,0,0,0.5);
  }
  .loc-pulse {
    width: 22px; height: 22px;
    background: rgba(33,150,243,0.4);
    border-radius: 50%;
    position: absolute;
    top: 0; left: 0;
    animation: loc-pulse 1.8s ease-out infinite;
  }
  @keyframes loc-pulse {
    0%   { transform: scale(0.7); opacity: 1; }
    100% { transform: scale(2.4); opacity: 0; }
  }

  .export-modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 248px;
    background: var(--bark);
    border: 1px solid var(--leaf);
    border-top: 3px solid var(--lime);
    z-index: 3000;
    padding: 14px;
    display: none;
    flex-direction: column;
    gap: 10px;
  }
  .export-modal.open { display: flex; }
  .export-modal h3 { font-family: 'Syne', sans-serif; font-size: 0.8rem; font-weight: 800; color: var(--lime); text-transform: uppercase; letter-spacing: 1px; }
  .export-check {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.72rem;
    color: var(--cream);
    cursor: pointer;
  }
  .export-check.dimmed { opacity: 0.4; pointer-events: none; }
  .export-check input[type=checkbox] { accent-color: var(--lime); cursor: pointer; }

  /* ── Mobile bottom bar ───────────────────────────────────────────────── */
  .mobile-bar {
    display: none;
    flex-direction: column;
    flex-shrink: 0;
    background: var(--bark);
    border-top: 2px solid var(--lime);
    z-index: 1000;
    padding-bottom: env(safe-area-inset-bottom, 0);
  }
  .mob-tools {
    display: flex;
    height: 68px;
  }
  .mob-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 5px;
    flex: 1;
    background: none;
    border: none;
    border-top: 2px solid transparent;
    color: var(--sand);
    font-family: 'Space Mono', monospace;
    font-size: 0.5rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    cursor: pointer;
    padding: 8px 2px;
    -webkit-tap-highlight-color: transparent;
    transition: color 0.1s, border-color 0.1s, background 0.1s;
  }
  .mob-btn svg { width: 24px; height: 24px; stroke: currentColor; flex-shrink: 0; }
  .mob-btn.active       { color: var(--lime); border-top-color: var(--lime); }
  .mob-btn.mob-locate   { color: #64b5f6; }
  .mob-btn.mob-locate.active { color: #fff; background: #1565c0; border-top-color: #2196f3; }

  /* ── Slide-up More drawer ─────────────────────────────────────────── */
  .mob-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.55);
    z-index: 1998;
    display: none;
  }
  .mob-overlay.open { display: block; }

  .mob-drawer {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    background: var(--bark2);
    border-top: 2px solid var(--lime);
    z-index: 1999;
    padding: 18px 16px;
    padding-bottom: calc(18px + env(safe-area-inset-bottom, 0));
    transform: translateY(100%);
    transition: transform 0.22s ease;
  }
  .mob-drawer.open { transform: translateY(0); }

  .mob-drawer-title {
    font-family: 'Syne', sans-serif;
    font-weight: 800;
    font-size: 0.72rem;
    color: var(--lime);
    text-transform: uppercase;
    letter-spacing: 1.5px;
    margin-bottom: 14px;
  }
  .mob-drawer-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }
  .mob-drawer-btn {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 14px;
    background: var(--forest2);
    border: 1px solid var(--leaf);
    color: var(--cream);
    font-family: 'Space Mono', monospace;
    font-size: 0.65rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    transition: background 0.1s;
  }
  .mob-drawer-btn svg   { width: 16px; height: 16px; flex-shrink: 0; stroke: var(--lime); }
  .mob-drawer-btn:active { background: var(--moss); }
  .mob-drawer-btn.full  { grid-column: span 2; }
  .mob-drawer-btn.danger { border-color: #c0392b; color: #e74c3c; }
  .mob-drawer-btn.danger svg { stroke: #e74c3c; }

  /* ── Mobile responsive ───────────────────────────────────────────────── */
  @media (max-width: 768px) {
    /* Minimal header — logo only, max map space */
    header { padding: 0 16px; height: 46px; }
    .logo span { display: none; }

    /* Hide desktop toolbar and status bar */
    .toolbar { display: none; }
    .status-bar { display: none; }

    /* Show mobile bottom bar */
    .mobile-bar { display: flex; }

    /* Cruise panel: full width below header, scrollable if tall */
    .cruise-panel { right: 8px; left: 8px; width: auto; top: 52px; max-height: calc(100vh - 130px); overflow-y: auto; }

    /* Export modal: full width */
    .export-modal { width: calc(100vw - 32px); left: 16px; transform: translateY(-50%); }

    /* Drop overlay: between header and mobile bar */
    .drop-overlay { top: 46px; bottom: 68px; }
  }
</style>
</head>
<body>

<header>
  <a class="logo" href="index.html">WoodyForestry<span>/ GIS Draw</span></a>
  <div class="toolbar">
    <button class="tool-btn" id="btn-polygon" onclick="startDraw('polygon')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="12,2 22,20 2,20"/></svg>
      Polygon
    </button>
    <button class="tool-btn" id="btn-polyline" onclick="startDraw('polyline')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="2,20 8,8 16,14 22,4"/></svg>
      Line
    </button>
    <button class="tool-btn" id="btn-marker" onclick="startDraw('marker')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="10" r="3"/><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7z"/></svg>
      Point
    </button>
    <div class="sep"></div>
    <button class="tool-btn" id="btn-edit" onclick="toggleEdit()">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
      Edit
    </button>
    <button class="tool-btn clear-btn" onclick="clearAll()">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3,6 5,6 21,6"/><path d="M19,6l-1,14H6L5,6"/><path d="M10,11v6"/><path d="M14,11v6"/></svg>
      Clear
    </button>
    <div class="sep"></div>
    <button class="tool-btn locate-btn" id="btn-locate" onclick="toggleLocate()" title="Show my location">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M12 2v3M12 19v3M2 12h3M19 12h3"/><circle cx="12" cy="12" r="7" stroke-opacity="0.35"/></svg>
      Locate Me
    </button>
    <div class="sep"></div>
    <button class="tool-btn" id="btn-cruise" onclick="toggleCruisePanel()">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="5" cy="5" r="1.5" fill="currentColor"/><circle cx="12" cy="5" r="1.5" fill="currentColor"/><circle cx="19" cy="5" r="1.5" fill="currentColor"/><circle cx="5" cy="12" r="1.5" fill="currentColor"/><circle cx="12" cy="12" r="1.5" fill="currentColor"/><circle cx="19" cy="12" r="1.5" fill="currentColor"/><circle cx="5" cy="19" r="1.5" fill="currentColor"/><circle cx="12" cy="19" r="1.5" fill="currentColor"/><circle cx="19" cy="19" r="1.5" fill="currentColor"/></svg>
      Cruise Grid
    </button>
    <div class="sep"></div>
    <button class="tool-btn upload-btn" onclick="document.getElementById('shp-upload-input').click()">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7,10 12,5 17,10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
      Upload .SHP
    </button>
    <button class="tool-btn export-btn" onclick="exportShapefile()">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7,10 12,15 17,10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
      Export .SHP
    </button>
  </div>
</header>

<!-- Cruise Grid Panel -->
<div class="cruise-panel" id="cruise-panel">
  <h3>⊞ Cruise Grid</h3>
  <div class="field-group">
    <div class="field-label">Target Polygons</div>
    <div class="poly-checklist" id="cruise-poly-list">
      <span class="poly-check empty">— Draw or upload a polygon first —</span>
    </div>
  </div>
  <div class="field-label" style="margin-bottom:4px;">Grid Spacing (chains)</div>
  <div class="cruise-row">
    <div class="field-group">
      <div class="field-label">↔ Col (X)</div>
      <input class="cruise-input" id="cruise-spacing-x" type="number" value="5" min="0.5" step="0.5"/>
    </div>
    <div class="field-group">
      <div class="field-label">↕ Row (Y)</div>
      <input class="cruise-input" id="cruise-spacing-y" type="number" value="5" min="0.5" step="0.5"/>
    </div>
  </div>
  <div class="field-group">
    <div class="field-label">Bearing (°)</div>
    <input class="cruise-input" id="cruise-bearing" type="number" value="0" min="0" max="359" step="1"/>
  </div>
  <div class="cruise-actions">
    <button class="btn-generate" onclick="generateCruiseGrid()">Generate</button>
    <button class="btn-clear-grid" onclick="clearCruiseGrid()">Clear</button>
  </div>
  <div class="cruise-info" id="cruise-info">No grid generated yet.</div>
</div>

<div id="map"></div>

<div class="status-bar">
  <div>Features: <span id="feat-count">0</span></div>
  <div id="acres-display" style="display:none">Stand Area: <span id="acres-val" style="color:var(--lime)">—</span> ac</div>
  <div>Active tool: <span id="active-tool">None</span></div>
  <div>CRS: <span>WGS84 / EPSG:4326</span></div>
  <div id="coords-display"></div>
</div>

<!-- Mobile bottom toolbar -->
<div class="mobile-bar">
  <div class="mob-tools">
    <button class="mob-btn mob-locate" id="mob-btn-locate" onclick="toggleLocate()">
      <svg viewBox="0 0 24 24" fill="none" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M12 2v3M12 19v3M2 12h3M19 12h3"/><circle cx="12" cy="12" r="7" stroke-opacity="0.4"/></svg>
      Locate
    </button>
    <button class="mob-btn" id="mob-btn-polygon" onclick="startDraw('polygon')">
      <svg viewBox="0 0 24 24" fill="none" stroke-width="2"><polygon points="12,2 22,20 2,20"/></svg>
      Polygon
    </button>
    <button class="mob-btn" id="mob-btn-polyline" onclick="startDraw('polyline')">
      <svg viewBox="0 0 24 24" fill="none" stroke-width="2"><polyline points="2,20 8,8 16,14 22,4"/></svg>
      Line
    </button>
    <button class="mob-btn" id="mob-btn-marker" onclick="startDraw('marker')">
      <svg viewBox="0 0 24 24" fill="none" stroke-width="2"><circle cx="12" cy="10" r="3"/><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7z"/></svg>
      Point
    </button>
    <button class="mob-btn" onclick="openMobileMenu()">
      <svg viewBox="0 0 24 24" fill="none" stroke-width="2"><circle cx="5" cy="12" r="1.5" fill="currentColor"/><circle cx="12" cy="12" r="1.5" fill="currentColor"/><circle cx="19" cy="12" r="1.5" fill="currentColor"/></svg>
      More
    </button>
  </div>
</div>

<!-- More drawer -->
<div class="mob-overlay" id="mob-overlay" onclick="closeMobileMenu()"></div>
<div class="mob-drawer" id="mob-drawer">
  <div class="mob-drawer-title">More Tools</div>
  <div class="mob-drawer-grid">
    <button class="mob-drawer-btn" onclick="closeMobileMenu(); toggleCruisePanel()">
      <svg viewBox="0 0 24 24" fill="none" stroke-width="1.5"><circle cx="5" cy="5" r="1.5" fill="currentColor" stroke="none"/><circle cx="12" cy="5" r="1.5" fill="currentColor" stroke="none"/><circle cx="19" cy="5" r="1.5" fill="currentColor" stroke="none"/><circle cx="5" cy="12" r="1.5" fill="currentColor" stroke="none"/><circle cx="12" cy="12" r="1.5" fill="currentColor" stroke="none"/><circle cx="19" cy="12" r="1.5" fill="currentColor" stroke="none"/><circle cx="5" cy="19" r="1.5" fill="currentColor" stroke="none"/><circle cx="12" cy="19" r="1.5" fill="currentColor" stroke="none"/><circle cx="19" cy="19" r="1.5" fill="currentColor" stroke="none"/></svg>
      Cruise Grid
    </button>
    <button class="mob-drawer-btn" onclick="closeMobileMenu(); toggleEdit()">
      <svg viewBox="0 0 24 24" fill="none" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
      Edit Shapes
    </button>
    <button class="mob-drawer-btn" onclick="closeMobileMenu(); document.getElementById('shp-upload-input').click()">
      <svg viewBox="0 0 24 24" fill="none" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7,10 12,5 17,10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
      Upload .SHP
    </button>
    <button class="mob-drawer-btn" onclick="closeMobileMenu(); exportShapefile()">
      <svg viewBox="0 0 24 24" fill="none" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7,10 12,15 17,10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
      Export .SHP
    </button>
    <button class="mob-drawer-btn full danger" onclick="closeMobileMenu(); clearAll()">
      <svg viewBox="0 0 24 24" fill="none" stroke-width="2"><polyline points="3,6 5,6 21,6"/><path d="M19,6l-1,14H6L5,6"/><path d="M10,11v6"/><path d="M14,11v6"/></svg>
      Clear All Features
    </button>
  </div>
</div>

<div class="notification" id="notif"></div>

<!-- Export selection modal -->
<div class="export-modal" id="export-modal">
  <h3>↓ Export Shapefile</h3>
  <div class="field-label">Select layers to export:</div>
  <label class="export-check" id="exp-drawn-label">
    <input type="checkbox" id="exp-drawn" checked>
    Drawn Features (<span id="exp-drawn-count">0</span>)
  </label>
  <label class="export-check" id="exp-cruise-label">
    <input type="checkbox" id="exp-cruise" checked>
    Cruise Points (<span id="exp-cruise-count">0</span>)
  </label>
  <div class="cruise-actions" style="margin-top:4px;">
    <button class="btn-clear-grid" onclick="closeExportModal()">Cancel</button>
    <button class="btn-generate" onclick="doExport()">Export</button>
  </div>
</div>

<input type="file" id="shp-upload-input" accept=".shp,.dbf,.shx,.prj,.zip" multiple style="display:none"
  onchange="handleShpFiles(this.files); this.value='';">

<div class="drop-overlay" id="drop-overlay">
  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7,10 12,5 17,10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
  <p>Drop Shapefile Here</p>
  <small>.shp + .dbf (+ .shx)&nbsp;&nbsp;or&nbsp;&nbsp;.zip</small>
</div>

<!-- Libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>

<script>
// ── Map setup ──────────────────────────────────────────────────────────────
const map = L.map('map', { zoomControl: true }).setView([35.5, -79.5], 7);

const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '© OpenStreetMap contributors',
  maxZoom: 19
});

const satellite = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
  attribution: '© Google',
  maxZoom: 20
});

const topo = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
  attribution: '© OpenTopoMap',
  maxZoom: 17
});

osm.addTo(map);

// ── NC OneMap Parcels WMS ──────────────────────────────────────────────────
const ncParcels = L.tileLayer.wms('https://cgia.nc.gov/arcgis/services/Cadastre/NC_Parcels/MapServer/WMSServer', {
  layers: '0',
  format: 'image/png',
  transparent: true,
  version: '1.3.0',
  attribution: '© NC OneMap',
  opacity: 0.6
});

const layerControl = L.control.layers({
  'Streets (OSM)': osm,
  'Satellite': satellite,
  'Topo': topo
}, {
  'NC Parcels (OneMap)': ncParcels
}, { position: 'topright' }).addTo(map);

map.on('mousemove', e => {
  document.getElementById('coords-display').textContent =
    `Lat: ${e.latlng.lat.toFixed(5)}  Lng: ${e.latlng.lng.toFixed(5)}`;
});

// ── Draw layer ─────────────────────────────────────────────────────────────
const drawnItems = new L.FeatureGroup();
map.addLayer(drawnItems);

const drawControl = new L.Control.Draw({
  edit: { featureGroup: drawnItems },
  draw: {
    polygon: { shapeOptions: { color: '#8bc34a', fillOpacity: 0.2 } },
    polyline: { shapeOptions: { color: '#8bc34a' } },
    marker: true,
    rectangle: false,
    circle: false,
    circlemarker: false
  }
});
map.addControl(drawControl);

map.on(L.Draw.Event.CREATED, e => {
  drawnItems.addLayer(e.layer);
  updateCount();
  refreshPolySelect();
  updateAcres();
  if (e.layer instanceof L.Polygon) {
    const acres = calcAcres(e.layer);
    e.layer.bindPopup(`<b>${acres.toFixed(2)} acres</b>`).openPopup();
  }
  notify('Feature added');
});

map.on(L.Draw.Event.EDITED, () => { updateCount(); refreshPolySelect(); updateAcres(); });
map.on(L.Draw.Event.DELETED, () => { updateCount(); refreshPolySelect(); updateAcres(); });

function updateCount() {
  document.getElementById('feat-count').textContent = drawnItems.getLayers().length;
}

// ── Acres calculation ──────────────────────────────────────────────────────
function calcAcres(layer) {
  const lls = layer.getLatLngs()[0];
  // Shoelace formula on projected coords (meters), then convert to acres
  const R = 6378137;
  let area = 0;
  const n = lls.length;
  for (let i = 0; i < n; i++) {
    const j = (i + 1) % n;
    const xi = lls[i].lng * Math.PI / 180 * R * Math.cos(lls[i].lat * Math.PI / 180);
    const yi = lls[i].lat * Math.PI / 180 * R;
    const xj = lls[j].lng * Math.PI / 180 * R * Math.cos(lls[j].lat * Math.PI / 180);
    const yj = lls[j].lat * Math.PI / 180 * R;
    area += xi * yj - xj * yi;
  }
  const sqMeters = Math.abs(area / 2);
  return sqMeters * 0.000247105; // m² to acres
}

function updateAcres() {
  let totalAcres = 0;
  let polyCount = 0;
  drawnItems.eachLayer(layer => {
    if (layer instanceof L.Polygon) {
      totalAcres += calcAcres(layer);
      polyCount++;
    }
  });
  const display = document.getElementById('acres-display');
  const val = document.getElementById('acres-val');
  if (polyCount > 0) {
    display.style.display = 'block';
    val.textContent = totalAcres.toFixed(2) + (polyCount > 1 ? ` (${polyCount} stands)` : '');
  } else {
    display.style.display = 'none';
  }
}

// ── Draw tool wrappers ─────────────────────────────────────────────────────
let currentHandler = null;

function clearToolActive() {
  document.querySelectorAll('.tool-btn, .mob-btn').forEach(b => b.classList.remove('active'));
}

function startDraw(type) {
  if (currentHandler) { currentHandler.disable(); currentHandler = null; }

  clearToolActive();
  document.getElementById('btn-' + type).classList.add('active');
  const mob = document.getElementById('mob-btn-' + type);
  if (mob) mob.classList.add('active');
  document.getElementById('active-tool').textContent = type.charAt(0).toUpperCase() + type.slice(1);

  const opts = {
    polygon: () => new L.Draw.Polygon(map, { shapeOptions: { color: '#8bc34a', fillOpacity: 0.2 } }),
    polyline: () => new L.Draw.Polyline(map, { shapeOptions: { color: '#8bc34a' } }),
    marker: () => new L.Draw.Marker(map)
  };

  currentHandler = opts[type]();
  currentHandler.enable();

  map.once(L.Draw.Event.CREATED, () => {
    currentHandler = null;
    clearToolActive();
    document.getElementById('active-tool').textContent = 'None';
  });
}

let editEnabled = false;
function toggleEdit() {
  editEnabled = !editEnabled;
  document.getElementById('btn-edit').classList.toggle('active', editEnabled);
  document.getElementById('active-tool').textContent = editEnabled ? 'Edit' : 'None';
  if (editEnabled) {
    drawControl._toolbars.edit._modes.edit.handler.enable();
  } else {
    drawControl._toolbars.edit._modes.edit.handler.disable();
  }
}

function clearAll() {
  if (!drawnItems.getLayers().length) return;
  if (confirm('Clear all features?')) {
    drawnItems.clearLayers();
    updateCount();
    notify('All features cleared');
  }
}

// ── Shapefile export ───────────────────────────────────────────────────────
// We'll write our own minimal shapefile writer so there are zero external deps

function exportShapefile() {
  const drawnCount = drawnItems.getLayers().length;
  const cruiseCount = cruisePoints.length;
  if (!drawnCount && !cruiseCount) { notify('Nothing to export'); return; }

  document.getElementById('exp-drawn-count').textContent = drawnCount;
  document.getElementById('exp-cruise-count').textContent = cruiseCount;

  const drawnLabel = document.getElementById('exp-drawn-label');
  const cruiseLabel = document.getElementById('exp-cruise-label');
  drawnLabel.classList.toggle('dimmed', !drawnCount);
  cruiseLabel.classList.toggle('dimmed', !cruiseCount);
  document.getElementById('exp-drawn').checked = drawnCount > 0;
  document.getElementById('exp-cruise').checked = cruiseCount > 0;

  document.getElementById('export-modal').classList.add('open');
}

function closeExportModal() {
  document.getElementById('export-modal').classList.remove('open');
}

function doExport() {
  closeExportModal();
  const inclDrawn  = document.getElementById('exp-drawn').checked;
  const inclCruise = document.getElementById('exp-cruise').checked;
  if (!inclDrawn && !inclCruise) { notify('Nothing selected to export'); return; }

  const zip = new JSZip();
  const prjContent = 'GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]]';

  if (inclDrawn) {
    const points = [], lines = [], polygons = [];
    drawnItems.getLayers().forEach(layer => {
      if (layer instanceof L.Marker) {
        points.push({ type: 'Point', coordinates: [layer.getLatLng().lng, layer.getLatLng().lat] });
      } else if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
        const lls = layer.getLatLngs();
        lines.push({ type: 'LineString', coordinates: lls.map(ll => [ll.lng, ll.lat]) });
      } else if (layer instanceof L.Polygon) {
        const lls = layer.getLatLngs()[0];
        const ring = lls.map(ll => [ll.lng, ll.lat]);
        ring.push(ring[0]);
        polygons.push({ type: 'Polygon', coordinates: [ring] });
      }
    });
    if (points.length) {
      zip.file('points.shp', buildPointShp(points));
      zip.file('points.shx', buildPointShx(points));
      zip.file('points.dbf', buildDbf(points.length));
      zip.file('points.prj', prjContent);
    }
    if (lines.length) {
      zip.file('lines.shp', buildPolylineShp(lines));
      zip.file('lines.shx', buildPolylineShx(lines));
      zip.file('lines.dbf', buildDbf(lines.length));
      zip.file('lines.prj', prjContent);
    }
    if (polygons.length) {
      zip.file('polygons.shp', buildPolygonShp(polygons));
      zip.file('polygons.shx', buildPolygonShx(polygons));
      zip.file('polygons.dbf', buildDbf(polygons.length));
      zip.file('polygons.prj', prjContent);
    }
  }

  if (inclCruise && cruisePoints.length) {
    const cruisePtGeoms = cruisePoints.map(p => ({ type: 'Point', coordinates: [p.lng, p.lat], id: p.id }));
    zip.file('cruise_points.shp', buildPointShp(cruisePtGeoms));
    zip.file('cruise_points.shx', buildPointShx(cruisePtGeoms));
    zip.file('cruise_points.dbf', buildCruiseDbf(cruisePoints));
    zip.file('cruise_points.prj', prjContent);
  }

  zip.generateAsync({ type: 'blob' }).then(blob => {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'forestdraw_export.zip';
    a.click();
    notify('Shapefile exported!');
  });
}

// ── Shapefile binary writers ───────────────────────────────────────────────

function writeInt32BE(view, offset, val) { view.setInt32(offset, val, false); }
function writeInt32LE(view, offset, val) { view.setInt32(offset, val, true); }
function writeDouble(view, offset, val)  { view.setFloat64(offset, val, true); }

function calcBbox(coords) {
  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
  coords.forEach(([x,y]) => { if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y; });
  return [minX, minY, maxX, maxY];
}

function buildFileHeader(fileLength, shapeType, bbox) {
  const buf = new ArrayBuffer(100);
  const view = new DataView(buf);
  writeInt32BE(view, 0, 9994);
  writeInt32BE(view, 24, fileLength); // in 16-bit words
  writeInt32LE(view, 28, 1000); // version
  writeInt32LE(view, 32, shapeType);
  writeDouble(view, 36, bbox[0]);
  writeDouble(view, 44, bbox[1]);
  writeDouble(view, 52, bbox[2]);
  writeDouble(view, 60, bbox[3]);
  return buf;
}

// ── POINT shapefile ────────────────────────────────────────────────────────
function buildPointShp(points) {
  const recordSize = 8 + 4 + 16; // header + shape type + x,y
  const fileLen = 100 + points.length * recordSize;
  const allCoords = points.map(p => p.coordinates);
  const bbox = calcBbox(allCoords);
  const buf = new ArrayBuffer(fileLen);
  const view = new DataView(buf);

  const hdr = new DataView(buildFileHeader(fileLen / 2, 1, bbox));
  for (let i = 0; i < 100; i++) view.setUint8(i, hdr.getUint8(i));

  let offset = 100;
  points.forEach((pt, i) => {
    writeInt32BE(view, offset, i + 1);
    writeInt32BE(view, offset + 4, (4 + 16) / 2);
    writeInt32LE(view, offset + 8, 1);
    writeDouble(view, offset + 12, pt.coordinates[0]);
    writeDouble(view, offset + 20, pt.coordinates[1]);
    offset += recordSize;
  });
  return buf;
}

function buildPointShx(points) {
  const fileLen = 100 + points.length * 8;
  const allCoords = points.map(p => p.coordinates);
  const bbox = calcBbox(allCoords);
  const buf = new ArrayBuffer(fileLen);
  const view = new DataView(buf);
  const hdr = new DataView(buildFileHeader(fileLen / 2, 1, bbox));
  for (let i = 0; i < 100; i++) view.setUint8(i, hdr.getUint8(i));
  let offset = 100;
  const recordSize = 8 + 4 + 16;
  points.forEach((_, i) => {
    writeInt32BE(view, offset, (100 + i * recordSize) / 2);
    writeInt32BE(view, offset + 4, (4 + 16) / 2);
    offset += 8;
  });
  return buf;
}

// ── POLYLINE shapefile ─────────────────────────────────────────────────────
function buildPolylineShp(lines) {
  const parts = [];
  lines.forEach(line => {
    const pts = line.coordinates;
    const contentLen = 4 + 32 + 4 + 4 + 4 * 1 + pts.length * 16;
    parts.push({ pts, contentLen });
  });
  const fileLen = 100 + parts.reduce((s, p) => s + 8 + p.contentLen, 0);
  const allPts = lines.flatMap(l => l.coordinates);
  const bbox = calcBbox(allPts);

  const buf = new ArrayBuffer(fileLen);
  const view = new DataView(buf);
  const hdr = new DataView(buildFileHeader(fileLen / 2, 3, bbox));
  for (let i = 0; i < 100; i++) view.setUint8(i, hdr.getUint8(i));

  let offset = 100;
  parts.forEach((p, i) => {
    const lb = calcBbox(p.pts);
    writeInt32BE(view, offset, i + 1);
    writeInt32BE(view, offset + 4, p.contentLen / 2);
    offset += 8;
    writeInt32LE(view, offset, 3);
    writeDouble(view, offset + 4, lb[0]);
    writeDouble(view, offset + 12, lb[1]);
    writeDouble(view, offset + 20, lb[2]);
    writeDouble(view, offset + 28, lb[3]);
    writeInt32LE(view, offset + 36, 1);
    writeInt32LE(view, offset + 40, p.pts.length);
    writeInt32LE(view, offset + 44, 0);
    offset += 48;
    p.pts.forEach(([x, y]) => {
      writeDouble(view, offset, x);
      writeDouble(view, offset + 8, y);
      offset += 16;
    });
  });
  return buf;
}

function buildPolylineShx(lines) {
  const fileLen = 100 + lines.length * 8;
  const allPts = lines.flatMap(l => l.coordinates);
  const bbox = calcBbox(allPts);
  const buf = new ArrayBuffer(fileLen);
  const view = new DataView(buf);
  const hdr = new DataView(buildFileHeader(fileLen / 2, 3, bbox));
  for (let i = 0; i < 100; i++) view.setUint8(i, hdr.getUint8(i));
  let offset = 100;
  let recordOffset = 100;
  lines.forEach(line => {
    const contentLen = 4 + 32 + 4 + 4 + 4 + line.coordinates.length * 16;
    writeInt32BE(view, offset, recordOffset / 2);
    writeInt32BE(view, offset + 4, contentLen / 2);
    recordOffset += 8 + contentLen;
    offset += 8;
  });
  return buf;
}

// ── POLYGON shapefile ──────────────────────────────────────────────────────
function buildPolygonShp(polygons) {
  const parts = polygons.map(poly => {
    const pts = poly.coordinates[0];
    const contentLen = 4 + 32 + 4 + 4 + 4 * 1 + pts.length * 16;
    return { pts, contentLen };
  });
  const fileLen = 100 + parts.reduce((s, p) => s + 8 + p.contentLen, 0);
  const allPts = polygons.flatMap(p => p.coordinates[0]);
  const bbox = calcBbox(allPts);

  const buf = new ArrayBuffer(fileLen);
  const view = new DataView(buf);
  const hdr = new DataView(buildFileHeader(fileLen / 2, 5, bbox));
  for (let i = 0; i < 100; i++) view.setUint8(i, hdr.getUint8(i));

  let offset = 100;
  parts.forEach((p, i) => {
    const lb = calcBbox(p.pts);
    writeInt32BE(view, offset, i + 1);
    writeInt32BE(view, offset + 4, p.contentLen / 2);
    offset += 8;
    writeInt32LE(view, offset, 5);
    writeDouble(view, offset + 4, lb[0]);
    writeDouble(view, offset + 12, lb[1]);
    writeDouble(view, offset + 20, lb[2]);
    writeDouble(view, offset + 28, lb[3]);
    writeInt32LE(view, offset + 36, 1);
    writeInt32LE(view, offset + 40, p.pts.length);
    writeInt32LE(view, offset + 44, 0);
    offset += 48;
    p.pts.forEach(([x, y]) => {
      writeDouble(view, offset, x);
      writeDouble(view, offset + 8, y);
      offset += 16;
    });
  });
  return buf;
}

function buildPolygonShx(polygons) {
  const fileLen = 100 + polygons.length * 8;
  const allPts = polygons.flatMap(p => p.coordinates[0]);
  const bbox = calcBbox(allPts);
  const buf = new ArrayBuffer(fileLen);
  const view = new DataView(buf);
  const hdr = new DataView(buildFileHeader(fileLen / 2, 5, bbox));
  for (let i = 0; i < 100; i++) view.setUint8(i, hdr.getUint8(i));
  let offset = 100;
  let recordOffset = 100;
  polygons.forEach(poly => {
    const contentLen = 4 + 32 + 4 + 4 + 4 + poly.coordinates[0].length * 16;
    writeInt32BE(view, offset, recordOffset / 2);
    writeInt32BE(view, offset + 4, contentLen / 2);
    recordOffset += 8 + contentLen;
    offset += 8;
  });
  return buf;
}

// ── DBF with PLOT_ID for cruise points ────────────────────────────────────
function buildCruiseDbf(points) {
  const headerSize = 32 + 32 + 1;
  const recordSize = 1 + 10;
  const totalSize = headerSize + points.length * recordSize;
  const buf = new ArrayBuffer(totalSize);
  const view = new DataView(buf);
  const bytes = new Uint8Array(buf);
  const enc = new TextEncoder();

  bytes[0] = 3;
  const now = new Date();
  bytes[1] = now.getFullYear() - 1900;
  bytes[2] = now.getMonth() + 1;
  bytes[3] = now.getDate();
  view.setInt32(4, points.length, true);
  view.setInt16(8, headerSize, true);
  view.setInt16(10, recordSize, true);

  const fName = enc.encode('PLOT_ID   ');
  for (let i = 0; i < 10; i++) bytes[32 + i] = fName[i];
  bytes[32 + 11] = 78;
  bytes[32 + 16] = 10;
  bytes[32 + 17] = 0;
  bytes[32 + 32] = 0x0D;

  let offset = headerSize;
  points.forEach(p => {
    bytes[offset] = 0x20;
    const s = String(p.id).padStart(10, ' ');
    const sb = enc.encode(s);
    for (let j = 0; j < 10; j++) bytes[offset + 1 + j] = sb[j];
    offset += recordSize;
  });
  return buf;
}

// ── DBF (minimal, no attributes) ──────────────────────────────────────────
function buildDbf(count) {
  // 1 field: FID
  const headerSize = 32 + 32 + 1; // header + 1 field descriptor + terminator
  const recordSize = 1 + 10; // deletion flag + FID (10 chars)
  const totalSize = headerSize + count * recordSize;
  const buf = new ArrayBuffer(totalSize);
  const view = new DataView(buf);
  const bytes = new Uint8Array(buf);

  bytes[0] = 3; // dBASE III
  const now = new Date();
  bytes[1] = now.getFullYear() - 1900;
  bytes[2] = now.getMonth() + 1;
  bytes[3] = now.getDate();
  view.setInt32(4, count, true);
  view.setInt16(8, headerSize, true);
  view.setInt16(10, recordSize, true);

  // Field descriptor at offset 32
  const enc = new TextEncoder();
  const fName = enc.encode('FID       '); // 10 chars
  for (let i = 0; i < 10; i++) bytes[32 + i] = fName[i];
  bytes[32 + 11] = 78; // 'N' numeric
  bytes[32 + 16] = 10; // field length
  bytes[32 + 17] = 0;  // decimal count
  bytes[32 + 32] = 0x0D; // header terminator

  let offset = headerSize;
  for (let i = 0; i < count; i++) {
    bytes[offset] = 0x20; // not deleted
    const fidStr = String(i + 1).padStart(10, ' ');
    const fidBytes = enc.encode(fidStr);
    for (let j = 0; j < 10; j++) bytes[offset + 1 + j] = fidBytes[j];
    offset += recordSize;
  }
  return buf;
}

// ── Cruise Grid ────────────────────────────────────────────────────────────

const CHAIN_METERS = 20.1168; // 1 chain = 20.1168 meters

let cruiseLayer = null;
let cruisePoints = []; // [{lat, lng, id}]
let polygonLayers = []; // track drawn polygons for select dropdown
let uploadedPolygons = []; // [{layer: L.Polygon, name: string}] from uploaded shapefiles

function toggleCruisePanel() {
  const panel = document.getElementById('cruise-panel');
  const btn = document.getElementById('btn-cruise');
  panel.classList.toggle('open');
  btn.classList.toggle('active');
  refreshPolySelect();
}

function refreshPolySelect() {
  const list = document.getElementById('cruise-poly-list');
  list.innerHTML = '';
  polygonLayers = [];

  const addItem = (layer, label) => {
    const idx = polygonLayers.length;
    polygonLayers.push(layer);
    const lbl = document.createElement('label');
    lbl.className = 'poly-check';
    lbl.title = label;
    lbl.innerHTML = `<input type="checkbox" value="${idx}" checked> ${label}`;
    list.appendChild(lbl);
  };

  // Drawn polygons
  let drawnCount = 0;
  drawnItems.eachLayer(layer => {
    if (layer instanceof L.Polygon) {
      drawnCount++;
      addItem(layer, `Stand Polygon ${drawnCount}`);
    }
  });

  // Uploaded shapefile polygons
  uploadedPolygons.forEach(entry => addItem(entry.layer, entry.name));

  if (!polygonLayers.length) {
    const span = document.createElement('span');
    span.className = 'poly-check empty';
    span.textContent = '— Draw or upload a polygon first —';
    list.appendChild(span);
  }
}

function generateCruiseGrid() {
  const spacingX = parseFloat(document.getElementById('cruise-spacing-x').value);
  const spacingY = parseFloat(document.getElementById('cruise-spacing-y').value);
  const bearingDeg = parseFloat(document.getElementById('cruise-bearing').value);

  const checked = Array.from(document.querySelectorAll('#cruise-poly-list input[type=checkbox]:checked'));
  const selectedIndices = checked.map(c => parseInt(c.value)).filter(i => !isNaN(i));

  if (!selectedIndices.length) {
    notify('Select at least one polygon'); return;
  }
  if (isNaN(spacingX) || spacingX <= 0 || isNaN(spacingY) || spacingY <= 0) {
    notify('Enter valid chain spacing'); return;
  }

  const rings = selectedIndices.map(i => {
    const lls = polygonLayers[i].getLatLngs()[0];
    return lls.map(ll => [ll.lng, ll.lat]);
  });

  const allCoords = rings.flat();
  const centerLat = allCoords.reduce((s, c) => s + c[1], 0) / allCoords.length;
  const spacingXm = spacingX * CHAIN_METERS;
  const spacingYm = spacingY * CHAIN_METERS;
  const dLng = spacingXm / (111320 * Math.cos(centerLat * Math.PI / 180));
  const dLat = spacingYm / 111320;

  const theta = bearingDeg * Math.PI / 180;

  const allLngs = allCoords.map(c => c[0]);
  const allLats = allCoords.map(c => c[1]);
  const minLng = Math.min(...allLngs), maxLng = Math.max(...allLngs);
  const minLat = Math.min(...allLats), maxLat = Math.max(...allLats);
  const cLng = (minLng + maxLng) / 2;
  const cLat = (minLat + maxLat) / 2;

  const diagLat = (maxLat - minLat);
  const diagLng = (maxLng - minLng);
  const expand = Math.sqrt(diagLat * diagLat + diagLng * diagLng) * 0.7 + Math.max(dLat, dLng) * 2;

  const stepsLat = Math.ceil((diagLat + expand * 2) / dLat) + 4;
  const stepsLng = Math.ceil((diagLng + expand * 2) / dLng) + 4;

  const pts = [];
  for (let i = -stepsLat; i <= stepsLat; i++) {
    for (let j = -stepsLng; j <= stepsLng; j++) {
      const dlat0 = i * dLat;
      const dlng0 = j * dLng;
      const dlat = dlat0 * Math.cos(theta) - dlng0 * Math.sin(theta) * Math.cos(centerLat * Math.PI / 180);
      const dlng = dlat0 * Math.sin(theta) / Math.cos(centerLat * Math.PI / 180) + dlng0 * Math.cos(theta);
      pts.push([cLng + dlng, cLat + dlat]);
    }
  }

  const inside = pts.filter(pt => rings.some(ring => pointInPolygon(pt, ring)));
  if (!inside.length) { notify('No points generated — check spacing/polygon'); return; }

  if (cruiseLayer) map.removeLayer(cruiseLayer);
  cruiseLayer = L.layerGroup();
  cruisePoints = [];

  inside.forEach((pt, i) => {
    const marker = L.circleMarker([pt[1], pt[0]], {
      radius: 5,
      color: '#ff6b35',
      fillColor: '#ff6b35',
      fillOpacity: 0.9,
      weight: 1.5
    });
    marker.bindTooltip(`Plot ${i + 1}`, { permanent: false, direction: 'top' });
    cruiseLayer.addLayer(marker);
    cruisePoints.push({ lng: pt[0], lat: pt[1], id: i + 1 });
  });

  cruiseLayer.addTo(map);

  document.getElementById('cruise-info').innerHTML =
    `<span>${inside.length}</span> cruise points · <span>${selectedIndices.length}</span> polygon${selectedIndices.length > 1 ? 's' : ''}<br>Spacing: <span>${spacingX}×${spacingY} ch</span> · Bearing: <span>${bearingDeg}°</span>`;

  notify(`${inside.length} cruise points generated`);
}

function clearCruiseGrid() {
  if (cruiseLayer) { map.removeLayer(cruiseLayer); cruiseLayer = null; }
  cruisePoints = [];
  document.getElementById('cruise-info').textContent = 'No grid generated yet.';
  notify('Cruise grid cleared');
}

// Ray-casting point-in-polygon
function pointInPolygon([px, py], ring) {
  let inside = false;
  for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
    const [xi, yi] = ring[i], [xj, yj] = ring[j];
    if (((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi) + xi)) {
      inside = !inside;
    }
  }
  return inside;
}

// ── Shapefile upload ───────────────────────────────────────────────────────

// Drag & drop wiring
document.addEventListener('dragover', e => {
  e.preventDefault();
  document.getElementById('drop-overlay').classList.add('active');
});
document.addEventListener('dragleave', e => {
  if (!e.relatedTarget) document.getElementById('drop-overlay').classList.remove('active');
});
document.addEventListener('drop', e => {
  e.preventDefault();
  document.getElementById('drop-overlay').classList.remove('active');
  handleShpFiles(e.dataTransfer.files);
});

function handleShpFiles(files) {
  const fileMap = {};
  Array.from(files).forEach(f => { fileMap[f.name.split('.').pop().toLowerCase()] = f; });

  // Zip bundle (.zip containing .shp + .dbf + optional .prj)
  if (fileMap.zip) {
    JSZip.loadAsync(fileMap.zip).then(zip => {
      let shpEntry = null, dbfEntry = null, prjEntry = null, name = 'upload';
      zip.forEach((path, entry) => {
        const ext = path.split('.').pop().toLowerCase();
        if (ext === 'shp') { shpEntry = entry; name = path.split('/').pop().replace(/\.shp$/i, ''); }
        if (ext === 'dbf') dbfEntry = entry;
        if (ext === 'prj') prjEntry = entry;
      });
      if (!shpEntry) { notify('No .shp found in zip'); return; }
      Promise.all([
        shpEntry.async('arraybuffer'),
        dbfEntry ? dbfEntry.async('arraybuffer') : Promise.resolve(null),
        prjEntry ? prjEntry.async('string') : Promise.resolve(null)
      ]).then(([s, d, p]) => loadShpLayer(s, d, name, p));
    }).catch(() => notify('Error reading zip'));
    return;
  }

  // Individual files
  if (!fileMap.shp) { notify('Select a .shp file (or .zip)'); return; }
  const name = fileMap.shp.name.replace(/\.shp$/i, '');
  const readBuf = f => new Promise(res => { const r = new FileReader(); r.onload = e => res(e.target.result); r.readAsArrayBuffer(f); });
  const readTxt = f => new Promise(res => { const r = new FileReader(); r.onload = e => res(e.target.result); r.readAsText(f); });
  Promise.all([
    readBuf(fileMap.shp),
    fileMap.dbf ? readBuf(fileMap.dbf) : Promise.resolve(null),
    fileMap.prj ? readTxt(fileMap.prj) : Promise.resolve(null)
  ]).then(([s, d, p]) => loadShpLayer(s, d, name, p));
}

function reprojectCoords(coords, fromProj) {
  if (typeof coords[0] === 'number') {
    const [x, y] = proj4(fromProj, 'WGS84', [coords[0], coords[1]]);
    return [x, y];
  }
  return coords.map(c => reprojectCoords(c, fromProj));
}

function loadShpLayer(shpBuf, dbfBuf, name, prjWkt) {
  let features;
  try { features = readShpFeatures(shpBuf); }
  catch(e) { notify('Invalid shapefile'); return; }
  if (!features.length) { notify('Shapefile has no features'); return; }

  if (dbfBuf) {
    try {
      const attrs = readDbfRecords(dbfBuf);
      features.forEach((f, i) => { if (attrs[i]) f.properties = attrs[i]; });
    } catch(e) {}
  }

  // Reproject from source CRS to WGS84 if .prj was provided
  if (prjWkt && typeof proj4 !== 'undefined') {
    try {
      features = features.map(f => f.geometry
        ? { ...f, geometry: { ...f.geometry, coordinates: reprojectCoords(f.geometry.coordinates, prjWkt) } }
        : f
      );
    } catch(e) { console.warn('[SHP] reprojection failed:', e); notify('Warning: could not reproject coordinates'); }
  }

  const layer = L.geoJSON({ type: 'FeatureCollection', features }, {
    style: () => ({ color: '#e5c229', weight: 2, fillOpacity: 0.15, fillColor: '#e5c229' }),
    pointToLayer: (feat, ll) => L.circleMarker(ll, {
      radius: 5, color: '#e5c229', fillColor: '#e5c229', fillOpacity: 0.9, weight: 1.5
    }),
    onEachFeature: (feat, lyr) => {
      const p = feat.properties;
      if (p && Object.keys(p).length) {
        lyr.bindPopup(Object.entries(p).slice(0, 10).map(([k, v]) => `<b>${k}:</b> ${v}`).join('<br>'));
      }
    }
  }).addTo(map);

  try { map.fitBounds(layer.getBounds().pad(0.1)); } catch(e) {}
  layerControl.addOverlay(layer, `⬆ ${name}`);

  // Register any polygon/multipolygon features for use as cruise grid targets
  let polyCount = 0;
  features.forEach((feat, idx) => {
    const g = feat.geometry;
    const firstProp = Object.values(feat.properties || {}).find(v => v && String(v).trim());
    const baseLabel = firstProp ? `${name}: ${firstProp}` : `${name} #${idx + 1}`;
    if (g.type === 'Polygon') {
      const latlngs = g.coordinates[0].map(([lng, lat]) => L.latLng(lat, lng));
      uploadedPolygons.push({ layer: L.polygon(latlngs), name: baseLabel });
      polyCount++;
    } else if (g.type === 'MultiPolygon') {
      g.coordinates.forEach((polyCoords, j) => {
        const latlngs = polyCoords[0].map(([lng, lat]) => L.latLng(lat, lng));
        uploadedPolygons.push({ layer: L.polygon(latlngs), name: `${baseLabel} pt.${j + 1}` });
        polyCount++;
      });
    }
  });

  if (polyCount) refreshPolySelect();
  notify(`Loaded ${name} — ${features.length} features${polyCount ? ` (${polyCount} polygon${polyCount > 1 ? 's' : ''} available for cruise grid)` : ''}`);
}

// ── Minimal .shp reader (Point / Polyline / Polygon) ──────────────────────
function readShpFeatures(buf) {
  const v = new DataView(buf);
  if (v.getInt32(0, false) !== 9994) throw new Error('Not a shapefile');
  const fileLen = v.getInt32(24, false) * 2;
  const features = [];
  let off = 100;

  while (off + 8 <= fileLen) {
    const contentLen = v.getInt32(off + 4, false) * 2;
    off += 8;
    if (off + contentLen > fileLen) break;
    const t = v.getInt32(off, true);

    if (t === 1 || t === 11 || t === 21) { // Point / PointZ / PointM
      features.push({
        type: 'Feature',
        geometry: { type: 'Point', coordinates: [v.getFloat64(off+4,true), v.getFloat64(off+12,true)] },
        properties: {}
      });
    } else if (t === 3 || t === 5 || t === 13 || t === 15 || t === 23 || t === 25) { // Polyline/Polygon + Z/M variants
      const nParts = v.getInt32(off+36, true);
      const nPts   = v.getInt32(off+40, true);
      const parts  = Array.from({ length: nParts }, (_, i) => v.getInt32(off+44+i*4, true));
      const ptBase = off + 44 + nParts * 4;
      const pts    = Array.from({ length: nPts }, (_, i) => [
        v.getFloat64(ptBase+i*16, true),
        v.getFloat64(ptBase+i*16+8, true)
      ]);
      const rings  = parts.map((s, i) => pts.slice(s, i+1 < nParts ? parts[i+1] : nPts));

      if (t === 3) {
        features.push({
          type: 'Feature',
          geometry: rings.length === 1
            ? { type: 'LineString', coordinates: rings[0] }
            : { type: 'MultiLineString', coordinates: rings },
          properties: {}
        });
      } else {
        // Classify rings: clockwise winding = outer, counter-clockwise = hole
        const signed = rings.map(r => {
          let a = 0;
          for (let i = 0, j = r.length-1; i < r.length; j=i++) a += (r[j][0]+r[i][0])*(r[j][1]-r[i][1]);
          return { ring: r, outer: a > 0 };
        });
        const outers = signed.filter(c => c.outer).map(c => c.ring);
        const holes  = signed.filter(c => !c.outer).map(c => c.ring);
        if (!outers.length) outers.push(rings[0]); // fallback

        if (outers.length === 1) {
          features.push({ type: 'Feature', geometry: { type: 'Polygon', coordinates: [outers[0], ...holes] }, properties: {} });
        } else {
          features.push({ type: 'Feature', geometry: { type: 'MultiPolygon', coordinates: outers.map(o => [o]) }, properties: {} });
        }
      }
    }
    off += contentLen;
  }
  return features;
}

// ── Minimal .dbf reader ────────────────────────────────────────────────────
function readDbfRecords(buf) {
  const v = new DataView(buf);
  const b = new Uint8Array(buf);
  const dec = new TextDecoder('latin1');
  const nRec  = v.getInt32(4, true);
  const hSize = v.getInt16(8, true);
  const rSize = v.getInt16(10, true);
  const fields = [];
  for (let off = 32; off < hSize - 1 && b[off] !== 0x0D; off += 32) {
    fields.push({ nm: dec.decode(b.slice(off, off+11)).replace(/\0/g, '').trim(), len: b[off+16] });
  }
  const records = [];
  for (let i = 0, off = hSize; i < nRec; i++, off += rSize) {
    if (b[off] === 0x2A) continue; // deleted record
    const rec = {};
    let fo = off + 1;
    fields.forEach(f => { rec[f.nm] = dec.decode(b.slice(fo, fo+f.len)).trim(); fo += f.len; });
    records.push(rec);
  }
  return records;
}

// ── Location tracking ──────────────────────────────────────────────────────
let locateLayer  = null;
let locateMarker = null;
let locateRing   = null;
let locateActive = false;
let locateFirst  = true;

function toggleLocate() {
  locateActive ? stopLocate() : startLocate();
}

function startLocate() {
  locateActive = true;
  locateFirst  = true;
  document.getElementById('btn-locate').classList.add('active');
  const ml = document.getElementById('mob-btn-locate');
  if (ml) ml.classList.add('active');
  document.getElementById('active-tool').textContent = 'Locating…';
  notify('Finding your location…');
  map.locate({ watch: true, setView: false, enableHighAccuracy: true });
}

function stopLocate() {
  locateActive = false;
  map.stopLocate();
  document.getElementById('btn-locate').classList.remove('active');
  const ml = document.getElementById('mob-btn-locate');
  if (ml) ml.classList.remove('active');
  document.getElementById('active-tool').textContent = 'None';
  if (locateLayer) { map.removeLayer(locateLayer); locateLayer = null; }
  locateMarker = null;
  locateRing   = null;
}

function openMobileMenu() {
  document.getElementById('mob-drawer').classList.add('open');
  document.getElementById('mob-overlay').classList.add('open');
}
function closeMobileMenu() {
  document.getElementById('mob-drawer').classList.remove('open');
  document.getElementById('mob-overlay').classList.remove('open');
}

map.on('locationfound', e => {
  if (!locateActive) return;
  const { latlng, accuracy } = e;

  if (!locateLayer) {
    locateLayer = L.layerGroup().addTo(map);

    locateRing = L.circle(latlng, {
      radius: accuracy,
      color: '#2196f3', fillColor: '#2196f3',
      fillOpacity: 0.1, weight: 1.5,
      interactive: false
    });

    locateMarker = L.marker(latlng, {
      icon: L.divIcon({
        className: '',
        html: '<div class="loc-pulse"></div><div class="loc-dot"></div>',
        iconSize: [22, 22],
        iconAnchor: [11, 11]
      }),
      interactive: false,
      zIndexOffset: 1000
    });

    locateLayer.addLayer(locateRing);
    locateLayer.addLayer(locateMarker);
  } else {
    locateMarker.setLatLng(latlng);
    locateRing.setLatLng(latlng).setRadius(accuracy);
  }

  if (locateFirst) {
    map.setView(latlng, Math.max(map.getZoom(), 17));
    locateFirst = false;
    notify(`Location found · ±${Math.round(accuracy)} m`);
    document.getElementById('active-tool').textContent = 'Locating';
  }
});

map.on('locationerror', e => {
  if (!locateActive) return;
  stopLocate();
  notify(e.code === 1 ? 'Location permission denied' : 'Location unavailable');
});

// ── Notification helper ────────────────────────────────────────────────────
function notify(msg) {
  const n = document.getElementById('notif');
  n.textContent = msg;
  n.classList.add('show');
  setTimeout(() => n.classList.remove('show'), 2500);
}
</script>

<!-- JSZip for bundling the .zip -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<!-- proj4js for reprojecting shapefiles in non-WGS84 CRS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>

</body>
</html>
